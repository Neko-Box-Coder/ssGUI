<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>03. Cloning And EventCallback.txt</title><link rel="stylesheet" type="text/css" href="../../styles/main.css" /><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 (Development Release 1) -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.indexOf("?Theme=") == 0){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }if (document.documentElement.className == undefined){ document.documentElement.className = t + "Theme"; }else{ document.documentElement.className += " " + t + "Theme"; }}</script>

<a name="≥_Cloning_And_EventCallback"></a><a name="Topic2121"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">≥ Cloning And EventCallback</div>
</div>

<a name="🔽_Readme_Example"></a><a name="Topic50"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">🔽 Readme Example</div>
 <div class="CBody"><p>Hopefully by now, you are able to get ssGUI compiling and building.</p><p>To test it, we can try running the readme example (If you have <b>ssGUI_BUILD_EXAMPLES</b> option on in CMake, you should be able to find it under <b>ssGUI/Examples/ReadmeExampleV7</b> in you binary folder)</p><pre class="CCode">#include <span class="SHString">&quot;ssGUI/HeaderGroups/StandardGroup.hpp&quot;</span><br />#include <span class="SHString">&quot;ssGUI/Extensions/Layout.hpp&quot;</span><br /><br /><span class="SHComment">//Readme example</span><br /><span class="SHKeyword">using namespace</span> ssGUI::Enums;<br /><span class="SHKeyword">int</span> main()<br />{<br />    ssGUI::MainWindow mainWindow;<br />    mainWindow.SetRenderSize(glm::vec2(<span class="SHNumber">450</span>, <span class="SHNumber">80</span>));<br />    mainWindow.AddExtension&lt;ssGUI::Extensions::Layout&gt;();<br /><br />    auto* text = mainWindow.AddChild&lt;ssGUI::Text&gt;();<br />    text-&gt;SetText(<span class="SHString">&quot;Click on the button to show the message&quot;</span>);<br /><br />    auto* button = mainWindow.AddChildWithWrapper&lt;ssGUI::StandardButton&gt;(AlignmentHorizontal::CENTER, AlignmentVertical::CENTER);<br />    button-&gt;SetSize(glm::vec2(<span class="SHNumber">50</span>, <span class="SHNumber">30</span>));<br /><br />    ssGUI::ssGUIManager guiManager;<br />    guiManager.AddRootGUIObject(&amp;mainWindow);<br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            <span class="SHKeyword">if</span>(button-&gt;GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)<br />                text-&gt;SetText(L<span class="SHString">&quot;(`oωo´)&quot;</span>);<br />        }<br />    );<br />    guiManager.StartRunning();<br />    <span class="SHKeyword">return</span> <span class="SHNumber">0</span>;<br />}</pre><p>and hopefully it looks something like this</p><div class="CImage"><a href="../../images/IntroductionExample.gif" target="_blank" class="ZoomLink"><img src="../../images/IntroductionExample.gif" loading="lazy" class="KnownDimensions" width="475" height="168" style="max-width: 475px" alt="IntroductionExample" /></a></div><p>_</p><p>We were adding the button to the mainWindow slightly differently compare to text:</p><pre class="CCode">mainWindow.AddChildWithWrapper&lt;ssGUI::StandardButton&gt;(AlignmentHorizontal::CENTER, AlignmentVertical::CENTER);</pre><p>_</p><p>Let's add the button without using <a href="../../index.html#File:◀️_ssGUI_API_▶️/DataClasses/Hierarchy.hpp:ssGUI.Hierarchy.AddChildWithWrapper" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,441);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >AddChildWithWrapper</a> and see what it will look like</p><pre class="CText">mainWindow.AddChild&lt;ssGUI::StandardButton&gt;();</pre><div class="CImage"><a href="../../images/03/withoutLayout.png" target="_blank" class="ZoomLink"><img src="../../images/03/withoutLayout.png" loading="lazy" class="KnownDimensions" width="464" height="121" style="max-width: 464px" alt="withoutLayout" /></a></div><p>Oof, seems like the button got resized to half of the window by layout.</p><p><a href="../../index.html#File:◀️_ssGUI_API_▶️/Extensions/Layout.hpp:ssGUI.Extensions.Layout" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1821);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::Extensions::Layout</a> controls the position and size of the child GUI objects automatically.</p><p>And what <a href="../../index.html#File:◀️_ssGUI_API_▶️/DataClasses/Hierarchy.hpp:ssGUI.Hierarchy.AddChildWithWrapper" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,441);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >AddChildWithWrapper</a> basically does is first creating an empty GUI Object as the child and then parent the &quot;actual&quot; child to the empty GUI Object so the layout extension won't affect the size of it. So something like this:</p><pre class="CText">mainWindow (which has layout extension)<br />│<br />└─► empty GUI Object (this is controlled by layout)<br />    │<br />    └─► your child</pre><p>and then finally adding a <a href="../../index.html#File:◀️_ssGUI_API_▶️/Extensions/AdvancedPosition.hpp:ssGUI.Extensions.AdvancedPosition" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1913);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >positioning extension</a> to do the alignment on it.</p><p>_</p><p>Then how come the text is not affected?</p><p>It is affecting the text GUI Object actually, it's just that the &quot;text&quot; size is controlled by &quot;font size&quot;, not the size of the GUI Object itself.</p><p>This becomes obvious when we add a border extension to the text to see what it looks like.</p><pre class="CCode">mainWindow.AddExtension&lt;ssGUI::Extensions::Layout&gt;()-&gt;AddPreferredSizeMultiplier(<span class="SHNumber">0.5</span>, <span class="SHNumber">0.5</span>);<br /><span class="SHComment">//...</span><br />text-&gt;AddExtension&lt;ssGUI::Extensions::Border&gt;()-&gt;SetBorderColor(glm::u8vec4(<span class="SHNumber">255</span>, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>, <span class="SHNumber">255</span>));<br /><span class="SHComment">//...</span></pre><p>When you run it (and resize the window to be bigger), you can see it is actually being affected but it doesn't affect the &quot;font size&quot;.</p><div class="CImage"><a href="../../images/03/textBorder.png" target="_blank" class="ZoomLink"><img src="../../images/03/textBorder.png" loading="lazy" class="KnownDimensions" width="597" height="186" style="max-width: 597px" alt="textBorder" /></a></div></div>
</div>

<a name="⏬_Infinite_Readme_Example"></a><a name="Topic53"></a><div class="CTopic TGroup LTextFile last">
 <div class="CTitle">⏬ Infinite Readme Example</div>
 <div class="CBody"><p>Let's try something more exciting (and somewhat practical).</p><p>Often times, we need a window or panel inside the &quot;actual&quot; window. Let's do that.</p><p>Most of the code is the same, except we are adding and using <a href="../../index.html#File:◀️_ssGUI_API_▶️/GUIObjectClasses/CompositeClasses/StandardWindow.hpp:ssGUI.StandardWindow" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,818);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::StandardWindow</a> to hold the text and button.</p><pre class="CCode"><span class="SHComment">//...</span><br /><span class="SHKeyword">int</span> main()<br />{<br />    ssGUI::MainWindow mainWindow;<br /><br />    <span class="SHComment">//Create a standard window, just a fancier window</span><br />    auto* window = mainWindow.AddChild&lt;ssGUI::StandardWindow&gt;();<br /><br />    <span class="SHComment">//We don't need docking</span><br />    window-&gt;RemoveAnyExtension&lt;ssGUI::Extensions::Dockable&gt;();<br />    window-&gt;SetRenderSize(glm::ivec2(<span class="SHNumber">450</span>, <span class="SHNumber">80</span>));<br />    window-&gt;AddExtension&lt;ssGUI::Extensions::Layout&gt;();<br />    <span class="SHComment">//...</span><br />    <span class="SHComment">//- auto* text = mainWindow.AddChild&lt;ssGUI::Text&gt;();</span><br />    auto* text = window-&gt;AddChild&lt;ssGUI::Text&gt;();<br />    <span class="SHComment">//...</span><br />    <span class="SHComment">//- auto* button = mainWindow.AddChildWithWrapper&lt;ssGUI::StandardButton&gt;(AlignmentHorizontal::CENTER, AlignmentVertical::CENTER);</span><br />    auto* button = window-&gt;AddChildWithWrapper&lt;ssGUI::StandardButton&gt;(AlignmentHorizontal::CENTER, AlignmentVertical::CENTER);<br />    <span class="SHComment">//...</span><br />}</pre><div class="CImage"><a href="../../images/IntroductionExampleAsWindow.gif" target="_blank" class="ZoomLink"><img src="../../images/IntroductionExampleAsWindow.gif" loading="lazy" class="KnownDimensions" width="517" height="529" style="max-width: 517px" alt="IntroductionExampleAsWindow" /></a></div><p>Cool, we now have our cool little window. Often times, we will have multiple GUI Objects that are mostly similar but with slight difference.</p><p>Creating each of them from the ground up doesn't sound too feasible, that's why we have a clone function.&nbsp; Let's add a button to clone our window.</p><pre class="CCode"><span class="SHComment">//...</span><br />#include <span class="SHString">&quot;ssGUI/Extensions/AdvancedPosition.hpp&quot;</span><br /><br /><span class="SHKeyword">int</span> main()<br />{<br />    <span class="SHComment">//...</span><br /><br />    <span class="SHComment">//A button for cloning the window</span><br />    auto* cloneButton = mainWindow.AddChild&lt;ssGUI::StandardButton&gt;();<br />    cloneButton-&gt;GetButtonTextObject()-&gt;SetText(<span class="SHString">&quot;Clone!!&quot;</span>);<br /><br />    <span class="SHComment">//We create an create an extension for positioning the button easily</span><br />    auto posExt = cloneButton-&gt;AddExtension&lt;ssGUI::Extensions::AdvancedPosition&gt;();<br /><br />    <span class="SHComment">//Setting it to be 20 pixels from the bottom of the parent</span><br />    posExt-&gt;SetVerticalAlignment(AlignmentVertical::BOTTOM);<br />    posExt-&gt;SetVerticalPixel(<span class="SHNumber">20</span>);<br /><br />    <span class="SHComment">//...</span><br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            <span class="SHKeyword">if</span>(button.GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)<br />                text.SetText(L<span class="SHString">&quot;(`oωo´)&quot;</span>);<br /><br />            <span class="SHComment">//If the button is clicked, we want to clone the window</span><br />            <span class="SHKeyword">if</span>(cloneButton.GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)<br />                window.Clone(<span class="SHKeyword">true</span>);<br />        }<br />    );<br />    <span class="SHComment">//...</span><br />}</pre><div class="CImage"><a href="../../images/03/cloningWindow.gif" target="_blank" class="ZoomLink"><img src="../../images/03/cloningWindow.gif" loading="lazy" class="KnownDimensions" width="517" height="529" style="max-width: 517px" alt="cloningWindow" /></a></div><p>But wait, what is this?</p><div class="CImage"><a href="../../images/03/clonedWindowButtonClicking.gif" target="_blank" class="ZoomLink"><img src="../../images/03/clonedWindowButtonClicking.gif" loading="lazy" class="KnownDimensions" width="517" height="529" style="max-width: 517px" alt="clonedWindowButtonClicking" /></a></div><p>It seems like the buttons on the cloned windows are not working, why is that?</p><p>The problem is in this section of the code</p><pre class="CCode"><span class="SHComment">//...</span><br />guiManager.AddPostGUIUpdateEventListener<br />(<br />    [&amp;]()<br />    {<br />        <span class="SHKeyword">if</span>(button.GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)<br />            text.SetText(L<span class="SHString">&quot;(`oωo´)&quot;</span>);<br /><br />        <span class="SHComment">//...</span></pre><p>We are checking only the button from the original window, not the ones that we cloned.</p><p>And we are modifying the text of the original window.</p><p>Checking each and all buttons every frame will be quite painful.</p><p>Remember <b>EventCallbacks</b> I mentioned earlier in <a href="../../index.html#File:🗒️_User_Manual/02._Getting_Started.txt:👟_Getting_Started" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,31);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >👟 Getting Started</a>? Here's where we need to use it.</p><pre class="CCode"><span class="SHComment">//...</span><br /><span class="SHKeyword">int</span> main()<br />{<br />    <span class="SHComment">//...</span><br /><br />    <span class="SHComment">//First we get the event callback for button state changed, it is attached to buttons by default.</span><br />    auto* buttonEventCallback =  button-&gt;GetEventCallback(ssGUI::Enums::EventType::BUTTON_STATE_CHANGED);<br /><br />    <span class="SHComment">//Then we add the text GUI Object to be referenced in the listener,</span><br />    <span class="SHComment">//  and pass the reference ID to the listener lambda</span><br />    ssGUI::ssGUIObjectIndex textId = buttonEventCallback-&gt;AddObjectReference(text);<br />    buttonEventCallback-&gt;AddEventListener<br />    (<br />        <span class="SHString">&quot;listenerKey&quot;</span>,<br />        [textId](ssGUI::EventInfo info)<br />        {<br />            auto* textToChange = info.References-&gt;GetObjectReference&lt;ssGUI::Text&gt;(textId);<br />            auto* currentButton = static_cast&lt;ssGUI::StandardButton*&gt;(info.Container);<br />            <span class="SHKeyword">if</span>(currentButton-&gt;GetButtonState() == ButtonState::CLICKED)<br />                textToChange-&gt;SetText(L<span class="SHString">&quot;(`oωo´)&quot;</span>);<br />        }<br />    );<br /><br />    <span class="SHComment">//...</span><br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            <span class="SHComment">//We don't need to check the button for changing text anymore...</span><br />            <span class="SHComment">//- if(button-&gt;GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)</span><br />            <span class="SHComment">//-     text-&gt;SetText(L&quot;(`oωo´)&quot;);</span><br /><br />            <span class="SHComment">//If the button is clicked, we want to clone the window</span><br />            <span class="SHKeyword">if</span>(cloneButton.GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)<br />                window.Clone(<span class="SHKeyword">true</span>);<br />        }<br />    );<br />    <span class="SHComment">//...</span><br />}</pre><div class="CImage"><a href="../../images/03/cloningWindowWithOR.gif" target="_blank" class="ZoomLink"><img src="../../images/03/cloningWindowWithOR.gif" loading="lazy" class="KnownDimensions" width="517" height="529" style="max-width: 517px" alt="cloningWindowWithOR" /></a></div><pre class="CText">⚠️ Don't worry if you don't get it, EventCallback might not seem intuitive at first,<br />  but it will be once you have used it multiple times.<br />  Everything else are a lot more straightforwards than this.</pre><p>Now the cloned button will still work even if you parent the text to something else, as long as the text is not deleted.</p><p>If it is, <a href="../../index.html#File:◀️_ssGUI_API_▶️/DataClasses/ObjectsReferences.hpp:ssGUI.ObjectsReferences.GetObjectReference" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,452);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ObjectsReferences::GetObjectReference</a> will return nullptr which you can check against.</p><pre class="CText">You can find source code under ssGUI/Src/Examples/CloningExampleV3</pre></div>
</div>

</body></html>