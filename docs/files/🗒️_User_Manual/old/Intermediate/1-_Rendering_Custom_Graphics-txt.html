<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>1. Rendering Custom Graphics.txt</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css" /><script type="text/javascript" src="../../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 (Development Release 1) -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.indexOf("?Theme=") == 0){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }if (document.documentElement.className == undefined){ document.documentElement.className = t + "Theme"; }else{ document.documentElement.className += " " + t + "Theme"; }}</script>

<a name="⚔️_Rendering_Custom_Graphics"></a><a name="Topic15"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">⚔️ Rendering Custom Graphics</div>
 <div class="CBody"><p>ssGUI fully supports OpenGL rendering before (or after or inbetween) rendering GUI Objects.</p><p>The only caveat is that you need to make sure to save and restore the OpenGL status</p><p>before and after rendering custom OpenGL graphics.</p></div>
</div>

<a name="⏱️_When_Can_You_Render_Custom_Graphics"></a><a name="Topic16"></a><div class="CTopic TSection LTextFile">
 <div class="CTitle">⏱️ When Can You Render Custom Graphics</div>
 <div class="CBody"><p>As mentioned in <a href="../../../../index.html#File:🗒️_User_Manual/02._Getting_Started.txt:👟_Getting_Started" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,31);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >👟 Getting Started</a>, <a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2055);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager</a> controls the order of</p><p>rendering and updating for the GUI Objects.</p><p>Here's a very brief overview of differnet stages of the &quot;update loop&quot; process in <a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2055);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager</a>:</p><pre class="CCode"><span class="SHComment">//==========================</span><br /><span class="SHComment">//Update Loop</span><br /><span class="SHComment">//==========================</span><br /><br /><span class="SHComment">//Poll Inputs</span><br /><br /><span class="SHComment">//Set cursor back to default cursor (Internally)</span><br /><br /><span class="SHComment">//&lt;ssGUIManagerPreUpdateEvent&gt;                                      //You can add listener to this event</span><br /><br /><span class="SHComment">//Update GUI Objects</span><br /><br /><span class="SHComment">//Deallocate any deleted GUI objects</span><br /><br /><span class="SHComment">//&lt;ssGUIManagerPostUpdateEvent&gt;                                     //You can add listener to this event</span><br /><br /><span class="SHKeyword">if</span>(IsCustomRendering)<br />    <span class="SHComment">//&lt;ssGUIManagerCustomRenderingEvent&gt;</span><br /><span class="SHKeyword">else</span><br />{<br />    <span class="SHComment">//Render GUI Objects (if any GUI Object needs to be redrawn)</span><br /><br />    <span class="SHComment">//&lt;ssGUIManagerPostRenderingUpdateEvent&gt;                        //You can add listener to this event</span><br /><br />    <span class="SHComment">//Swap buffers (if any GUI Object needs to be redrawn)</span><br /><br />    <span class="SHComment">//Clear buffer (Only color buffer for SFML)</span><br />}<br /><br /><span class="SHComment">//Update cursor if the cursor is different from last frame (System)</span><br /><br /><span class="SHComment">//Framerate limitation</span></pre><p>As you can see, there are three events you can add listener to for drawing custom graphics:</p><ul><li><p><a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPreGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2065);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager::AddPreGUIUpdateEventListener</a>: This will insert any logic/graphics before GUI Objects are drawn and updated</p></li><li><p><a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2067);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager::AddPostGUIUpdateEventListener</a>: This will insert any logic/graphics before GUI Objects are drawn</p></li><li><p>&lt;ssGUI::ssGUIManager::AddPostGUIRenderingUpdateEventListener&gt;: This will insert any logic/graphics after GUI Objects are drawn and updated.</p><p>However, the graphics might not be drawn if no GUI Objects needed to be redrawn.</p><p>If needed, You can force redraw every frame by calling &lt;ssGUI::ssGUIManager::SetForceRendering&gt; to true.</p></li></ul><p>⠀</p><p>For most case scenario, <a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2067);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager::AddPostGUIUpdateEventListener</a> should be good if you want to draw custom graphics</p><p>before GUI Objects are being drawn. This will also have the benefit of immediately reflecting any changes to your graphics</p><p>if the GUI Objects affects how your graphics are being drawn.</p><p>⠀</p><p>In order to draw custom graphics, you will need to save the state of the <a href="../../../../index.html#File:◀️_ssGUI_API_▶️/Backend/Interfaces/BackendDrawingInterface.hpp:ssGUI.Backend.BackendDrawingInterface" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1218);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::Backend::BackendDrawingInterface</a> and</p><p>restore it when you are done with it. However, <b>DO NOT</b> call display (swap buffers)</p><p>as this is handled by <a href="../../../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2055);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager</a>. So the code will look something like this:</p><pre class="CCode">guiManager.AddPostGUIUpdateEventListener<br />(<br />    [&amp;]()<br />    {<br />        <span class="SHComment">//Save OpenGL status</span><br />        mainWindow.GetBackendDrawingInterface()-&gt;SaveState();<br /><br />        <span class="SHComment">//OpenGL Code for drawing...</span><br /><br />        <span class="SHComment">//Restore OpenGL status</span><br />        mainWindow.GetBackendDrawingInterface()-&gt;RestoreState();<br />    }<br />);</pre></div>
</div>

<a name="Full_Example"></a><a name="Topic17"></a><div class="CTopic TSection LTextFile last">
 <div class="CTitle">Full Example</div>
 <div class="CBody"><p>You can find the file in Src/Examples/CustomGraphicsExample.cpp</p><div class="CImage"><a href="../../../../images/CustomGraphics.gif" target="_blank" class="ZoomLink"><img src="../../../../images/CustomGraphics.gif" loading="lazy" class="KnownDimensions" width="833" height="455" style="max-width: 833px" alt="CustomGraphics" /></a></div><pre class="CCode">#include <span class="SHString">&quot;ssGUI/HeaderGroups/StandardGroup.hpp&quot;</span><br />#include <span class="SHString">&quot;ssGUI/Extensions/AdvancedPosition.hpp&quot;</span><br />#include <span class="SHString">&quot;ssGUI/Extensions/Layout.hpp&quot;</span><br /><br /><span class="SHComment">// I don't have macOS, so &lt;GL/gl.h&gt; might also work, idk.</span><br />#<span class="SHKeyword">if</span> __APPLE__<br />#   include &lt;OpenGL/gl.h&gt;<br />#   include &lt;OpenGL/glu.h&gt;<br />#<span class="SHKeyword">else</span><br />#   include &lt;GL/gl.h&gt;<br />#   include &lt;GL/glu.h&gt;<br />#endif<br /><br />#include &lt;SFML/Graphics.hpp&gt;<br /><br /><span class="SHComment">//Modified version of this:</span><br /><span class="SHComment">//Credit to: https://www3.ntu.edu.sg/home/ehchua/programming/opengl/CG_Examples.html</span><br /><br /><span class="SHComment">//===================================================================================</span><br /><span class="SHComment">//OpenGL code</span><br /><span class="SHComment">//===================================================================================</span><br /><span class="SHComment">/* Global variables */</span><br />GLfloat anglePyramid = <span class="SHNumber">0.0f</span>;                <span class="SHComment">// Rotational angle for pyramid [NEW]</span><br />GLfloat angleCube = <span class="SHNumber">0.0f</span>;                   <span class="SHComment">// Rotational angle for cube [NEW]</span><br /><span class="SHKeyword">int</span> refreshMills = <span class="SHNumber">15</span>;                      <span class="SHComment">// refresh interval in milliseconds [NEW]</span><br /><br />GLfloat PyramidRotateSpeed = <span class="SHNumber">0.5</span> * <span class="SHNumber">3</span>;       <span class="SHComment">// Rotational angle for pyramid [NEW]</span><br />GLfloat CubeRotateSpeed = <span class="SHNumber">0.5</span> * <span class="SHNumber">3</span>;          <span class="SHComment">// Rotational angle for pyramid [NEW]</span><br /><br /><br /><span class="SHComment">/* Initialize OpenGL Graphics */</span><br /><span class="SHKeyword">void</span> initGL()<br />{<br />    glEnable(GL_DEPTH_TEST);                                <span class="SHComment">// Enable depth testing for z-culling</span><br />    glDepthFunc(GL_LESS);                                   <span class="SHComment">// Set the type of depth-test</span><br />    glShadeModel(GL_SMOOTH);                                <span class="SHComment">// Enable smooth shading</span><br />    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);      <span class="SHComment">// Nice perspective corrections</span><br />}<br /><br /><span class="SHComment">/* Handler for window-repaint event. Called back when the window first appears and</span><br /><span class="SHComment">whenever the window needs to be re-painted. */</span><br /><span class="SHKeyword">void</span> display()<br />{<br />    glMatrixMode(GL_MODELVIEW);                                 <span class="SHComment">// To operate on model-view matrix</span><br />    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br /><br />    <span class="SHComment">// Render a color-cube consisting of 6 quads with different colors</span><br />    glLoadIdentity();                                           <span class="SHComment">// Reset the model-view matrix</span><br />    glTranslatef(<span class="SHNumber">1.5f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">-7.0f</span>);                            <span class="SHComment">// Move right and into the screen</span><br />    glRotatef(angleCube, <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>);                     <span class="SHComment">// Rotate about (1,1,1)-axis [NEW]</span><br /><br />    glBegin(GL_QUADS);                                          <span class="SHComment">// Begin drawing the color cube with 6 quads</span><br />        <span class="SHComment">// Top face (y = 1.0f)</span><br />        <span class="SHComment">// Define vertices in counter-clockwise (CCW) order with normal pointing out</span><br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Green</span><br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>);<br /><br />        <span class="SHComment">// Bottom face (y = -1.0f)</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.5f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Orange</span><br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br /><br />        <span class="SHComment">// Front face  (z = 1.0f)</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Red</span><br />        glVertex3f( <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br /><br />        <span class="SHComment">// Back face (z = -1.0f)</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Yellow</span><br />        glVertex3f( <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f( <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br /><br />        <span class="SHComment">// Left face (x = -1.0f)</span><br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>);     <span class="SHComment">// Blue</span><br />        glVertex3f(<span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>);<br /><br />        <span class="SHComment">// Right face (x = 1.0f)</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>);     <span class="SHComment">// Magenta</span><br />        glVertex3f(<span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glVertex3f(<span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>,  <span class="SHNumber">1.0f</span>);<br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />    glEnd();  <span class="SHComment">// End of drawing color-cube</span><br /><br />    <span class="SHComment">// Render a pyramid consists of 4 triangles</span><br />    glLoadIdentity();                                   <span class="SHComment">// Reset the model-view matrix</span><br />    glTranslatef(<span class="SHNumber">-1.5f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">-6.0f</span>);                   <span class="SHComment">// Move left and into the screen</span><br />    glRotatef(anglePyramid, <span class="SHNumber">1.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);          <span class="SHComment">// Rotate about the (1,1,0)-axis [NEW]</span><br /><br />    glBegin(GL_TRIANGLES);                              <span class="SHComment">// Begin drawing the pyramid with 4 triangles</span><br />        <span class="SHComment">// Front</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Red</span><br />        glVertex3f( <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Green</span><br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>);     <span class="SHComment">// Blue</span><br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br /><br />        <span class="SHComment">// Right</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Red</span><br />        glVertex3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>);     <span class="SHComment">// Blue</span><br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Green</span><br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br /><br />        <span class="SHComment">// Back</span><br />        glColor3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Red</span><br />        glVertex3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);     <span class="SHComment">// Green</span><br />        glVertex3f(<span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>, <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>);     <span class="SHComment">// Blue</span><br />        glVertex3f(<span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>);<br /><br />        <span class="SHComment">// Left</span><br />        glColor3f(<span class="SHNumber">1.0f</span>,<span class="SHNumber">0.0f</span>,<span class="SHNumber">0.0f</span>);       <span class="SHComment">// Red</span><br />        glVertex3f( <span class="SHNumber">0.0f</span>, <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>,<span class="SHNumber">0.0f</span>,<span class="SHNumber">1.0f</span>);       <span class="SHComment">// Blue</span><br />        glVertex3f(<span class="SHNumber">-1.0f</span>,<span class="SHNumber">-1.0f</span>,<span class="SHNumber">-1.0f</span>);<br />        glColor3f(<span class="SHNumber">0.0f</span>,<span class="SHNumber">1.0f</span>,<span class="SHNumber">0.0f</span>);       <span class="SHComment">// Green</span><br />        glVertex3f(<span class="SHNumber">-1.0f</span>,<span class="SHNumber">-1.0f</span>, <span class="SHNumber">1.0f</span>);<br />    glEnd();   <span class="SHComment">// Done drawing the pyramid</span><br /><br />    <span class="SHComment">// Update the rotational angle after each refresh [NEW]</span><br />    anglePyramid += PyramidRotateSpeed;<br />    angleCube -= CubeRotateSpeed;<br />}<br /><br /><span class="SHComment">/* Handler for window re-size event. Called back when the window first appears and</span><br /><span class="SHComment">whenever the window is re-sized with its new width and height */</span><br /><span class="SHKeyword">void</span> reshape(GLsizei width, GLsizei height)<br />{   <span class="SHComment">// GLsizei for non-negative integer</span><br />    <span class="SHComment">// Compute aspect ratio of the new window</span><br />    <span class="SHKeyword">if</span> (height == <span class="SHNumber">0</span>) height = <span class="SHNumber">1</span>;                <span class="SHComment">// To prevent divide by 0</span><br />    GLfloat aspect = (GLfloat)width / (GLfloat)height;<br /><br />    <span class="SHComment">// Set the viewport to cover the new window</span><br />    glViewport(<span class="SHNumber">0</span>, <span class="SHNumber">0</span>, width, height);<br /><br />    <span class="SHComment">// Set the aspect ratio of the clipping volume to match the viewport</span><br />    glMatrixMode(GL_PROJECTION);  <span class="SHComment">// To operate on the Projection matrix</span><br />    glLoadIdentity();             <span class="SHComment">// Reset</span><br /><br />    <span class="SHComment">// Enable perspective projection with fovy, aspect, zNear and zFar</span><br />    gluPerspective(<span class="SHNumber">45.0f</span>, aspect, <span class="SHNumber">0.1f</span>, <span class="SHNumber">100.0f</span>);<br />}<br /><br /><span class="SHComment">//===================================================================================</span><br /><span class="SHComment">//UI code</span><br /><span class="SHComment">//===================================================================================</span><br /><span class="SHKeyword">int</span> main()<br />{<br />    ssGUI::MainWindow mainWindow;<br />    mainWindow.SetSize(glm::vec2(<span class="SHNumber">800</span>, <span class="SHNumber">400</span>));<br /><br />    <span class="SHComment">//Create a window for rotation speed control</span><br />    ssGUI::StandardWindow window;<br />    window.GetWindowTitleObject()-&gt;SetText(<span class="SHString">&quot;Rotation Control&quot;</span>);<br />    window.SetParent(&amp;mainWindow);<br />    window.AddExtension(ssGUI::Factory::Create&lt;ssGUI::Extensions::Layout&gt;());<br />    window.GetAnyExtension&lt;ssGUI::Extensions::Layout&gt;()-&gt;SetUpdateContainerMinMaxSize(<span class="SHKeyword">false</span>);   <span class="SHComment">//By default, layout extension overrides the min max size</span><br />    window.SetMinSize(glm::vec2(<span class="SHNumber">240</span>, <span class="SHNumber">200</span>));<br />    <span class="SHKeyword">float</span> sizes[] = {<span class="SHNumber">0.2</span>, <span class="SHNumber">0.2</span>, <span class="SHNumber">0.2</span>, <span class="SHNumber">0.4</span>};<br />    window.GetAnyExtension&lt;ssGUI::Extensions::Layout&gt;()-&gt;AddPreferredSizeMultiplier(sizes, <span class="SHNumber">4</span>);<br /><br />    <span class="SHComment">//Pyramid Rotation Speed Text</span><br />    ssGUI::Text pyramidText;<br />    pyramidText.SetText(<span class="SHString">&quot;Pyramid Rotation Speed:&quot;</span>);<br />    pyramidText.SetHorizontalAlignment(ssGUI::Enums::TextAlignmentHorizontal::CENTER);<br />    pyramidText.SetVerticalAlignment(ssGUI::Enums::TextAlignmentVertical::BOTTOM);<br />    pyramidText.SetParent(&amp;window);<br /><br />    <span class="SHComment">//Pyramid Rotation Slider Slider</span><br />    ssGUI::Slider pyramidSlider;<br />    pyramidSlider.SetSize(glm::vec2(<span class="SHNumber">150</span>, <span class="SHNumber">10</span>));<br />    auto ecb = ssGUI::Factory::Create&lt;ssGUI::EventCallbacks::SliderValueFinishedChangingEventCallback&gt;();<br />    ecb-&gt;AddEventListener<br />    (<br />        <span class="SHString">&quot;pyramidControl&quot;</span>,<br />        [&amp;](ssGUI::EventInfo info)<br />        {<br />            PyramidRotateSpeed = static_cast&lt;ssGUI::Slider*&gt;(info.EventCallbackContainer)-&gt;GetSliderValue() * <span class="SHNumber">3</span>;<br />        }<br />    );<br />    pyramidSlider.AddExtension(ssGUI::Factory::Create&lt;ssGUI::Extensions::AdvancedPosition&gt;());<br />    pyramidSlider.AddEventCallback(ecb);<br />    window.GetAnyExtension&lt;ssGUI::Extensions::Layout&gt;()-&gt;AddChildWithWrapper(&amp;pyramidSlider);<br /><br />    <span class="SHComment">//Cube Rotation Speed Text</span><br />    ssGUI::Text* cubeText = pyramidText.Clone(<span class="SHKeyword">true</span>);<br />    cubeText-&gt;SetText(<span class="SHString">&quot;Cube Rotation Speed:&quot;</span>);<br /><br />    <span class="SHComment">//Cube Slider Wrapper so that slider's size is not overriden by layout</span><br />    ssGUI::Slider* cubeSlider = static_cast&lt;ssGUI::Slider*&gt;(pyramidSlider.Clone(<span class="SHKeyword">true</span>));<br />    ecb = cubeSlider-&gt;GetAnyEventCallback&lt;ssGUI::EventCallbacks::SliderValueFinishedChangingEventCallback&gt;();<br />    ecb-&gt;RemoveEventListener(<span class="SHString">&quot;pyramidControl&quot;</span>);<br />    ecb-&gt;AddEventListener<br />    (<br />        <span class="SHString">&quot;cubeControl&quot;</span>,<br />        [&amp;](ssGUI::EventInfo info)<br />        {<br />            CubeRotateSpeed = static_cast&lt;ssGUI::Slider*&gt;(info.EventCallbackContainer)-&gt;GetSliderValue() * <span class="SHNumber">3</span>;<br />        }<br />    );<br />    window.GetAnyExtension&lt;ssGUI::Extensions::Layout&gt;()-&gt;AddChildWithWrapper(cubeSlider);<br /><br />    <span class="SHComment">//Create ssGUIManager and start it</span><br />    ssGUI::ssGUIManager guiManager;<br />    guiManager.AddGUIObject(&amp;mainWindow);<br />    guiManager.SetForceRendering(<span class="SHKeyword">true</span>);<br /><br />    <span class="SHComment">//We want to draw GUI objects on top of OpenGL objects</span><br />    <span class="SHComment">//GUI Object updates before being render, so we can just draw OpenGL objects after GUI Objects update</span><br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            <span class="SHComment">//Save OpenGL status</span><br />            mainWindow.GetBackendDrawingInterface()-&gt;SaveState();<br /><br />            <span class="SHComment">//Draw OpenGL scene</span><br />            initGL();<br />            reshape(mainWindow.GetSize().x, mainWindow.GetSize().y);<br />            display();<br /><br />            <span class="SHComment">//Restore OpenGL status</span><br />            mainWindow.GetBackendDrawingInterface()-&gt;RestoreState();<br />        }<br />    );<br /><br />    guiManager.StartRunning();<br />    <span class="SHKeyword">return</span> <span class="SHNumber">0</span>;<br />}</pre></div>
</div>

</body></html>