<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>04. Full Window Custom Graphics.txt</title><link rel="stylesheet" type="text/css" href="../../styles/main.css" /><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 (Development Release 1) -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.indexOf("?Theme=") == 0){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }if (document.documentElement.className == undefined){ document.documentElement.className = t + "Theme"; }else{ document.documentElement.className += " " + t + "Theme"; }}</script>

<a name="⏱️_Full_Window_Custom_Graphics"></a><a name="Topic51"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">⏱️ Full Window Custom Graphics</div>
</div>

<a name="🌊_Flow_of_ssGUIManager_"></a><a name="Topic52"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">🌊 Flow of ssGUIManager:</div>
 <div class="CBody"><p>As I have mentioned before, <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2055);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::ssGUIManager</a> controls the flow of the program. It is actually quite striaghtforward.</p><div class="CHeading">Flow</div><ul><li><p>1. Poll input</p><ul><li><p>1.5.&nbsp; Pre update user event: <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPreGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2065);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PreGUIUpdateEventListener</a></p></li></ul></li><li><p>2. Update GUI Objects</p><ul><li><p>2.5. Post update user event: <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2067);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PostGUIUpdateEventListener</a></p></li></ul></li><li><p>3. Deallocate GUI Objects marked for deletion <u>(GUI Objects can be marked for deletion from any of the stages before this)</u></p></li><li><p>4. Render for each MainWindow</p><ul><li><p>4.5. Post render user event (per window): <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIRenderEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2071);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PostGUIRenderEventListener</a></p></li></ul></li></ul><p>_</p><p>Therefore, if you need to render custom graphics using the graphics API the backend uses (i.e. OpenGL), we need to render using one of those user events.</p><p>Normally, polygons that are rendered later will be in front of the ones that are rendered earlier, this is called <a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm" target="_top">Painter's algorithm</a>.</p><p>Knowing this, if you want to render custom graphics <b>in front of</b> ssGUI, you should render it during <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIRenderEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2071);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PostGUIRenderEventListener</a>.&nbsp; Otherwise, you should render it during <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2067);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PostGUIUpdateEventListener</a>.</p><p>_</p><p>In our case, since we want to render custom graphics <b>behind</b> ssGUI (because the FPS counter should be an overlay), we should render it in <a href="../../index.html#File:◀️_ssGUI_API_▶️/ssGUIManager.hpp:ssGUI.ssGUIManager.AddPostGUIUpdateEventListener" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2067);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >PostGUIUpdateEventListener</a>.</p></div>
</div>

<a name="⏱️_FPS_Counter_"></a><a name="Topic47"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">⏱️ FPS Counter:</div>
 <div class="CBody"><p>Let's get the FPS counter working first before rendering any custom graphics, since it is a lot shorter.</p><p>Let's say we want the FPS overlay to be on the top right, it will look something like this:</p><div class="CImage"><a href="../../images/04/TextPosition.png" target="_blank" class="ZoomLink"><img src="../../images/04/TextPosition.png" loading="lazy" class="KnownDimensions" width="517" height="260" style="max-width: 517px" alt="TextPosition" /></a></div><p>We first need to position the Text GUI Object to be top right, then the text content inside the Text GUI Object to be top right.</p><pre class="CCode">#include <span class="SHString">&quot;ssGUI/HeaderGroups/StandardGroup.hpp&quot;</span><br /><br /><span class="SHKeyword">void</span> CalculateAndShowFPS(ssGUI::ssGUIManager&amp; guiManager, ssGUI::Text&amp; fpsText)<br />{<br />    <span class="SHKeyword">static</span> uint64_t lastRecordedTime = guiManager.GetElapsedTimeInMillisecond();   <span class="SHComment">//Record the last time we displayed FPS</span><br />    <span class="SHKeyword">static int</span> frameCount = <span class="SHNumber">0</span>;<br />    <span class="SHKeyword">if</span>(guiManager.GetElapsedTimeInMillisecond() - lastRecordedTime &gt; <span class="SHNumber">1000</span>)<br />    {<br />        fpsText.SetText(<span class="SHString">&quot;Fps: &quot;</span>+std::to_string(frameCount));                       <span class="SHComment">//Set the content of the text GUI Object every second</span><br />        lastRecordedTime = guiManager.GetElapsedTimeInMillisecond();<br />        frameCount = <span class="SHNumber">0</span>;<br />    }<br />    frameCount++;<br />}<br /><br /><span class="SHKeyword">using namespace</span> ssGUI::Enums;<br /><span class="SHKeyword">int</span> main()<br />{<br />    ssGUI::MainWindow mainWindow;<br /><br />    auto* fpsText = mainWindow.AddChild&lt;ssGUI::Text&gt;();<br />    fpsText-&gt;SetNewTextColor(glm::u8vec4(<span class="SHNumber">0</span>, <span class="SHNumber">255</span>, <span class="SHNumber">0</span>, <span class="SHNumber">255</span>));                          <span class="SHComment">//Set the fps text color to green</span><br />    fpsText-&gt;SetAlignment(AlignmentHorizontal::RIGHT, AlignmentVertical::TOP);      <span class="SHComment">//Align content to top-right within itself</span><br />    fpsText-&gt;SetAnchorType(ssGUI::Enums::AnchorType::TOP_RIGHT);                    <span class="SHComment">//Anchor the text widget to the top-right of the window</span><br /><br />    ssGUI::ssGUIManager guiManager;<br />    guiManager.AddGUIObject((ssGUI::GUIObject*)&amp;mainWindow);<br /><br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            CalculateAndShowFPS(guiManager, *fpsText);<br />        }<br />    );<br />    guiManager.SetRedrawEveryFrame(<span class="SHKeyword">true</span>);           <span class="SHComment">//Forces ssGUIManager to render every frame</span><br />    guiManager.SetTargetFramerate(<span class="SHNumber">-1</span>);              <span class="SHComment">//By default, ssGUIManager limits the (update) framerate to 60.</span><br />    guiManager.StartRunning();                      <span class="SHComment">//      We set it to a negative number to disable it.</span><br />    <span class="SHKeyword">return</span> <span class="SHNumber">0</span>;<br />}</pre></div>
</div>

<a name="🎲_Custom_Graphics_with_OpenGL_"></a><a name="Topic49"></a><div class="CTopic TGroup LTextFile last">
 <div class="CTitle">🎲 Custom Graphics with OpenGL:</div>
 <div class="CBody"><p>Now we have added a FPS counter, lets display something with OpenGL.&nbsp; We are only rendering a single triangle just for demostration purposes, but you can do much more complex rendering.</p><p>The code we will be using is from <a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-2-the-first-triangle/" target="_top">opengl-tutorial.org</a> but slightly modified. We won't be explaining too much about it but some experience with OpenGL is adviced.</p><p>In order to use OpenGL functions, you can use this if you are using native backend</p><pre class="CText">#include &quot;glad/glad.h&quot;</pre><p>If you are using SFML backend, then you can use</p><pre class="CText">#include &lt;SFML/OpenGL.hpp&gt;</pre><p>_</p><p>Next, we can create function for compiling and linking shaders.&nbsp; We can put this function above the main function.</p><pre class="CCode"><span class="SHComment">//Modified from https://github.com/opengl-tutorials/ogl/blob/master/common/shader.cpp</span><br /><span class="SHKeyword">int</span> CreateShaders(std::<span class="SHKeyword">string</span>&amp; vertexShaderCode, std::<span class="SHKeyword">string</span>&amp; fragmentShaderCode)<br />{<br />    <span class="SHComment">// Create the shaders</span><br />    GLuint vertexShaderID = glCreateShader(GL_VERTEX_SHADER);<br />    GLuint fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);<br />    GLint result = GL_FALSE;<br />    <span class="SHKeyword">int</span> infoLogLength = <span class="SHNumber">0</span>;<br /><br />    <span class="SHComment">// Compile Vertex Shader</span><br />    ssLOG_LINE(<span class="SHString">&quot;Compiling vertex shader&quot;</span>);<br />    <span class="SHKeyword">const char</span>* vertexSourcePointer = vertexShaderCode.c_str();<br />    glShaderSource(vertexShaderID, <span class="SHNumber">1</span>, &amp;vertexSourcePointer , NULL);<br />    glCompileShader(vertexShaderID);<br /><br />    <span class="SHComment">// Check Vertex Shader</span><br />    glGetShaderiv(vertexShaderID, GL_COMPILE_STATUS, &amp;result);<br />    glGetShaderiv(vertexShaderID, GL_INFO_LOG_LENGTH, &amp;infoLogLength);<br />    <span class="SHKeyword">if</span> ( infoLogLength &gt; <span class="SHNumber">0</span> )<br />    {<br />        std::vector&lt;<span class="SHKeyword">char</span>&gt; VertexShaderErrorMessage(infoLogLength+<span class="SHNumber">1</span>);<br />        glGetShaderInfoLog(vertexShaderID, infoLogLength, NULL, &amp;VertexShaderErrorMessage[<span class="SHNumber">0</span>]);<br />        ssLOG_LINE(&amp;VertexShaderErrorMessage[<span class="SHNumber">0</span>]);<br />    }<br /><br />    <span class="SHComment">// Compile Fragment Shader</span><br />    ssLOG_LINE(<span class="SHString">&quot;Compiling fragment shader&quot;</span>);<br />    <span class="SHKeyword">const char</span>* fragmentSourcePointer = fragmentShaderCode.c_str();<br />    glShaderSource(fragmentShaderID, <span class="SHNumber">1</span>, &amp;fragmentSourcePointer , NULL);<br />    glCompileShader(fragmentShaderID);<br /><br />    <span class="SHComment">// Check Fragment Shader</span><br />    glGetShaderiv(fragmentShaderID, GL_COMPILE_STATUS, &amp;result);<br />    glGetShaderiv(fragmentShaderID, GL_INFO_LOG_LENGTH, &amp;infoLogLength);<br />    <span class="SHKeyword">if</span> ( infoLogLength &gt; <span class="SHNumber">0</span> )<br />    {<br />        std::vector&lt;<span class="SHKeyword">char</span>&gt; FragmentShaderErrorMessage(infoLogLength+<span class="SHNumber">1</span>);<br />        glGetShaderInfoLog(fragmentShaderID, infoLogLength, NULL, &amp;FragmentShaderErrorMessage[<span class="SHNumber">0</span>]);<br />        ssLOG_LINE(&amp;FragmentShaderErrorMessage[<span class="SHNumber">0</span>]);<br />    }<br /><br />    <span class="SHComment">// Link the program</span><br />    ssLOG_LINE(<span class="SHString">&quot;Linking program&quot;</span>);<br />    GLuint programID = glCreateProgram();<br />    glAttachShader(programID, vertexShaderID);<br />    glAttachShader(programID, fragmentShaderID);<br />    glLinkProgram(programID);<br /><br />    <span class="SHComment">// Check the program</span><br />    glGetProgramiv(programID, GL_LINK_STATUS, &amp;result);<br />    glGetProgramiv(programID, GL_INFO_LOG_LENGTH, &amp;infoLogLength);<br />    <span class="SHKeyword">if</span> ( infoLogLength &gt; <span class="SHNumber">0</span> ){<br />        std::vector&lt;<span class="SHKeyword">char</span>&gt; ProgramErrorMessage(infoLogLength+<span class="SHNumber">1</span>);<br />        glGetProgramInfoLog(programID, infoLogLength, NULL, &amp;ProgramErrorMessage[<span class="SHNumber">0</span>]);<br />        ssLOG_LINE(&amp;ProgramErrorMessage[<span class="SHNumber">0</span>]);<br />    }<br /><br />    glDetachShader(programID, vertexShaderID);<br />    glDetachShader(programID, fragmentShaderID);<br /><br />    glDeleteShader(vertexShaderID);<br />    glDeleteShader(fragmentShaderID);<br /><br />    <span class="SHKeyword">return</span> programID;<br />}</pre><p>_</p><p>Then we can use that function to create an initiation function like this</p><pre class="CCode"><span class="SHKeyword">void</span> InitiateRendering( GLuint&amp; vertexArrayID, GLuint&amp; programID, GLuint&amp; vertexbuffer)<br />{<br />    std::<span class="SHKeyword">string</span> vertexShader =<br />        <span class="SHString">&quot;#version 330 core\n\</span><br /><span class="SHString">        \</span><br /><span class="SHString">        // Input vertex data, different for all executions of this shader.\n\</span><br /><span class="SHString">        layout(location = 0) in vec3 vertexPosition_modelspace;\</span><br /><span class="SHString">        \</span><br /><span class="SHString">        void main()\</span><br /><span class="SHString">        {\</span><br /><span class="SHString">            gl_Position.xyz = vertexPosition_modelspace;\</span><br /><span class="SHString">            gl_Position.w = 1.0;\</span><br /><span class="SHString">        }&quot;</span>;<br /><br />    std::<span class="SHKeyword">string</span> fragmentShader =<br />        <span class="SHString">&quot;#version 330 core\n\</span><br /><span class="SHString">        \</span><br /><span class="SHString">        // Ouput data\n\</span><br /><span class="SHString">        out vec4 color;\</span><br /><span class="SHString">        \</span><br /><span class="SHString">        void main()\</span><br /><span class="SHString">        {\</span><br /><span class="SHString">            color = vec4(1,0,0,1);\</span><br /><span class="SHString">        }&quot;</span>;<br /><br />    glGenVertexArrays(<span class="SHNumber">1</span>, &amp;vertexArrayID);<br />    glBindVertexArray(vertexArrayID);<br /><br />    <span class="SHComment">// Create and compile our GLSL program from the shaders</span><br />    programID = CreateShaders(vertexShader, fragmentShader);<br /><br />    <span class="SHComment">//This is in clip space, so they are normalzied (0 to 1) instead of from 0 to width/height</span><br />    <span class="SHKeyword">static const</span> GLfloat g_vertex_buffer_data[] =<br />    {<br />        <span class="SHNumber">-1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">0.5f</span>,<br />         <span class="SHNumber">1.0f</span>, <span class="SHNumber">-1.0f</span>, <span class="SHNumber">0.5f</span>,<br />         <span class="SHNumber">0.0f</span>,  <span class="SHNumber">1.0f</span>, <span class="SHNumber">0.5f</span>,<br />    };<br /><br />    glGenBuffers(<span class="SHNumber">1</span>, &amp;vertexbuffer);<br />    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);<br />    glBufferData(GL_ARRAY_BUFFER, <span class="SHKeyword">sizeof</span>(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW);<br />}</pre><p>_</p><p>Finally, we can have a render function for drawing triangle every frame like this</p><pre class="CCode"><span class="SHKeyword">void</span> RenderGraphics(GLuint programID, GLuint vertexbuffer, ssGUI::MainWindow&amp; mainWindow)<br />{<br />    <span class="SHComment">//If we want to draw graphics on top of ssGUI, we need to call this</span><br />    <span class="SHComment">//  so that GUI is drawn to backbuffer before we draw anything to the back buffer</span><br />    <span class="SHComment">//mainWindow.GetBackendDrawingInterface()-&gt;DrawToBackBuffer();</span><br /><br />    mainWindow.SaveState();                   <span class="SHComment">//Saves the state ssGUI was using</span><br />    mainWindow.SetRenderContext();            <span class="SHComment">//Set the mainWindow to be the current context for OpenGL calls</span><br /><br />    glEnable(GL_DEPTH_TEST);<br /><br />    <span class="SHComment">// Use our shader</span><br />    glUseProgram(programID);<br />    glClear(GL_DEPTH_BUFFER_BIT);<br /><br />    <span class="SHComment">// Enable first attribute buffer</span><br />    glEnableVertexAttribArray(<span class="SHNumber">0</span>);<br />    glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer);<br />    glVertexAttribPointer(<br />        <span class="SHNumber">0</span>,                  <span class="SHComment">// attribute 0. No particular reason for 0, but must match the layout in the shader.</span><br />        <span class="SHNumber">3</span>,                  <span class="SHComment">// size</span><br />        GL_FLOAT,           <span class="SHComment">// type</span><br />        GL_FALSE,           <span class="SHComment">// normalized?</span><br />        <span class="SHNumber">0</span>,                  <span class="SHComment">// stride</span><br />        (<span class="SHKeyword">void</span>*)<span class="SHNumber">0</span>            <span class="SHComment">// array buffer offset</span><br />    );<br /><br />    <span class="SHComment">// Draw the triangle !</span><br />    glDrawArrays(GL_TRIANGLES, <span class="SHNumber">0</span>, <span class="SHNumber">3</span>); <span class="SHComment">// 3 indices starting at 0 -&gt; 1 triangle</span><br /><br />    glDisableVertexAttribArray(<span class="SHNumber">0</span>);<br />    glUseProgram(<span class="SHNumber">0</span>);<br /><br />    glDisable(GL_DEPTH_TEST);<br />    mainWindow.RestoreState();                <span class="SHComment">//Restores back the state ssGUI was using</span><br />}</pre><p>_</p><p>Last but not least, we can use the functions we created above in the PostGUIUpdateEvent which renders the custom graphics we have before rendering ssGUI. (But in this case, it doesn't really matter as they don't overlap each other).</p><pre class="CCode"><span class="SHKeyword">using namespace</span> ssGUI::Enums;<br /><span class="SHKeyword">int</span> main()<br />{<br />    ssGUI::MainWindow mainWindow;<br />    <span class="SHComment">//...</span><br /><br />    <span class="SHComment">//NOTE: It is very important to do any GL calls *AFTER* the first MainWindow creation</span><br />    <span class="SHComment">//      because it loads GLAD when a MainWindow is created the first time.</span><br />    GLuint vertexArrayID = <span class="SHNumber">0</span>;<br />    GLuint programID = <span class="SHNumber">0</span>;<br />    GLuint vertexbuffer = <span class="SHNumber">0</span>;<br />    InitiateRendering(vertexArrayID, programID, vertexbuffer);<br /><br />    <span class="SHComment">//...</span><br />    guiManager.AddPostGUIUpdateEventListener<br />    (<br />        [&amp;]()<br />        {<br />            CalculateAndShowFPS(guiManager, *fpsText);<br />            RenderGraphics(programID, vertexbuffer, mainWindow);    <span class="SHComment">//Render our graphics with the function we created earlier</span><br />        }<br />    );<br />    guiManager.SetRedrawEveryFrame(<span class="SHKeyword">true</span>);           <span class="SHComment">//Forces ssGUIManager to render every frame</span><br />    guiManager.SetTargetFramerate(<span class="SHNumber">-1</span>);              <span class="SHComment">//By default, ssGUIManager limits the (update) framerate to 60.</span><br />    guiManager.StartRunning();                      <span class="SHComment">//      We set it to a negative number to disable it.</span><br /><br />    <span class="SHComment">// Cleanup GL stuff</span><br />    glDeleteBuffers(<span class="SHNumber">1</span>, &amp;vertexbuffer);<br />    glDeleteVertexArrays(<span class="SHNumber">1</span>, &amp;vertexArrayID);<br />    glDeleteProgram(programID);<br />    <span class="SHKeyword">return</span> <span class="SHNumber">0</span>;<br />}</pre><p><u>The FPS color maybe a bit difficult to see, in this case you can set the background color to black like this</u></p><pre class="CText">mainWindow.SetBackgroundColor(glm::u8vec4(0, 0, 0, 255));</pre><div class="CImage"><a href="../../images/04/fps.gif" target="_blank" class="ZoomLink"><img src="../../images/04/fps.gif" loading="lazy" class="KnownDimensions" width="517" height="529" style="max-width: 517px" alt="fps" /></a></div><pre class="CText">You can find source code under ssGUI/Src/Examples/CustomGraphicsExampleV2</pre></div>
</div>

</body></html>