<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>OpenGL3_3_Common</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css" /><script type="text/javascript" src="../../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 (Development Release 1) -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.indexOf("?Theme=") == 0){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }if (document.documentElement.className == undefined){ document.documentElement.className = t + "Theme"; }else{ document.documentElement.className += " " + t + "Theme"; }}</script>

<a name="Topic878"></a><div class="CTopic TClass LC first">
 <div class="CTitle"><span class="Qualifier">ssGUI::&#8203;Backend::</span>&#8203;OpenGL3_3_Common</div>
 <div class="NDClassPrototype" id="NDClassPrototype878"><div class="CPEntry TClass Current"><div class="CPName"><span class="Qualifier">ssGUI::&#8203;Backend::</span>&#8203;OpenGL3_3_Common</div></div></div>
 <div class="CBody"><p>This is a common class for OpenGL backend on Linux and Windows. It uses the same shader for rendering everything.</p><p>Normally, you don't have to deal with this class.</p><div class="CHeading">Variables &amp; Constructor</div><pre class="CCode"><span class="SHKeyword">public</span>:<br />    <span class="SHKeyword">using</span> CharSize = uint16_t;<br />    <span class="SHKeyword">using</span> CharCode = uint32_t;<br />    <span class="SHKeyword">using</span> CharTextureIdentifier = std::tuple&lt;ssGUI::Backend::BackendFontInterface*, CharSize, CharCode&gt;;<br /><br /><span class="SHKeyword">private</span>:<br />    <span class="SHKeyword">static const</span> std::<span class="SHKeyword">string</span> VertShader;                                                <span class="SHComment">//(Internal variable) Vertex shader string</span><br />    <span class="SHKeyword">static const</span> std::<span class="SHKeyword">string</span> FragShader;                                                <span class="SHComment">//(Internal variable) Fragment shader string</span><br />    GLuint ProgramId;                                                                   <span class="SHComment">//(Internal variable) Program Id for drawing GUI</span><br />    GLuint CachedImages;                                                                <span class="SHComment">//(Internal variable) 2D texture array for storing the image atlas layers</span><br />    GLuint VAO;                                                                         <span class="SHComment">//(Internal variable) VAO for drawing GUI</span><br />    GLuint VertsVBO;                                                                    <span class="SHComment">//(Internal variable) VBO for storing vertices for drawing GUI</span><br />    GLuint ColorsVBO;                                                                   <span class="SHComment">//(Internal variable) VBO for storing colors for drawing GUI</span><br />    GLuint TexCoordsVBO;                                                                <span class="SHComment">//(Internal variable) VBO for storing texture coordinates (0 to image atlas size) for drawing GUI. If non texture, this is not used.</span><br />    GLuint TopLeftTexCoordsVBO;                                                         <span class="SHComment">//(Internal variable) VBO for storing top left position texture coordinates (0 to image atlas size) for drawing GUI.</span><br />                                                                                        <span class="SHComment">//                      If non texture, this will be negative to signal this shape is non texture.</span><br />    GLuint BotRightTexCoordsVBO;                                                        <span class="SHComment">//(Internal variable) VBO for storing bottom right position texture coordinates (0 to image atlas size) for drawing GUI.</span><br />    GLint LastViewportProperties[<span class="SHNumber">4</span>];                                                    <span class="SHComment">//(Internal variable) Used for recording the last viewport when drawing GUI</span><br /><br />    std::vector&lt;glm::vec2&gt; Vertices;                                                    <span class="SHComment">//(Internal variable) Internal buffer for storing shape vertices</span><br />    std::vector&lt;glm::vec4&gt; Colors;                                                      <span class="SHComment">//(Internal variable) Internal buffer for storing color</span><br />    std::vector&lt;glm::vec3&gt; TexCoords;                                                   <span class="SHComment">//(Internal variable) Internal buffer for storing texture coordinates</span><br />    std::vector&lt;glm::vec3&gt; TextureTopLeftCoords;                                        <span class="SHComment">//(Internal variable) Internal buffer for storing top left corner for texture in image atlas</span><br />    std::vector&lt;glm::vec3&gt; TextureBotRightCoords;                                       <span class="SHComment">//(Internal variable) Internal buffer for storing bottom right corner for texture in image atlas</span><br />    std::vector&lt;GLuint&gt; Idx;                                                            <span class="SHComment">//(Internal variable) Internal buffer for storing indices for drawing GUI shapes.</span><br /><br />    BackendMainWindowInterface* CurrentMainWindow;                                      <span class="SHComment">//(Internal variable) Used for performing viewport related operations</span><br /><br />    DynamicImageAtlas* CurrentImageAtlas;                                               <span class="SHComment">//(Internal variable) &lt;DynamicImageAtlas&gt; object for managing image atlas</span><br />    std::unordered_map&lt;ssGUI::Backend::BackendImageInterface*, <span class="SHKeyword">int</span>&gt; MappedImgIds;       <span class="SHComment">//See &lt;AddImageCache&gt;</span><br />    std::unordered_map&lt;CharTextureIdentifier, <span class="SHKeyword">int</span>&gt; MappedFontIds;                       <span class="SHComment">//See &lt;AddFontCache&gt;</span><br /><br />    <span class="SHKeyword">const int</span> VERT_POS_INDEX;                                                           <span class="SHComment">//(Internal variable) Shader layout location for vertex position</span><br />    <span class="SHKeyword">const int</span> VERT_COLOR_INDEX;                                                         <span class="SHComment">//(Internal variable) Shader layout location for color</span><br />    <span class="SHKeyword">const int</span> VERT_TEX_COORD_INDEX;                                                     <span class="SHComment">//(Internal variable) Shader layout location for texture coordinates</span><br />    <span class="SHKeyword">const int</span> VERT_TEX_TOP_LEFT_INDEX;                                                  <span class="SHComment">//(Internal variable) Shader layout location for top left texture coordinates</span><br />    <span class="SHKeyword">const int</span> VERT_TEX_BOT_RIGHT_INDEX;                                                 <span class="SHComment">//(Internal variable) Shader layout location for bot right texture coordinates</span></pre><pre class="CCode">OpenGL3_3_Common::OpenGL3_3_Common( BackendMainWindowInterface* mainWindow) :   ProgramId(<span class="SHNumber">0</span>),<br />                                                                                CachedImages(<span class="SHNumber">0</span>),<br />                                                                                VAO(<span class="SHNumber">0</span>),<br />                                                                                VertsVBO(<span class="SHNumber">0</span>),<br />                                                                                ColorsVBO(<span class="SHNumber">0</span>),<br />                                                                                TexCoordsVBO(<span class="SHNumber">0</span>),<br />                                                                                TopLeftTexCoordsVBO(<span class="SHNumber">0</span>),<br />                                                                                BotRightTexCoordsVBO(<span class="SHNumber">0</span>),<br />                                                                                LastViewportProperties(),<br />                                                                                Vertices(),<br />                                                                                Colors(),<br />                                                                                TexCoords(),<br />                                                                                TextureTopLeftCoords(),<br />                                                                                TextureBotRightCoords(),<br />                                                                                Idx(),<br />                                                                                CurrentMainWindow(nullptr),<br />                                                                                CurrentImageAtlas(nullptr),<br />                                                                                MappedImgIds(),<br />                                                                                MappedFontIds(),<br />                                                                                VERT_POS_INDEX(<span class="SHNumber">0</span>),<br />                                                                                VERT_COLOR_INDEX(<span class="SHNumber">1</span>),<br />                                                                                VERT_TEX_COORD_INDEX(<span class="SHNumber">2</span>),<br />                                                                                VERT_TEX_TOP_LEFT_INDEX(<span class="SHNumber">3</span>),<br />                                                                                VERT_TEX_BOT_RIGHT_INDEX(<span class="SHNumber">4</span>)<br />{<br />    CurrentMainWindow = mainWindow;<br /><br />    mainWindow-&gt;SetGLContext();<br /><br />    GLint maxTextureSize = <span class="SHNumber">0</span>;<br />    GLint maxLayerSize = <span class="SHNumber">0</span>;<br /><br />    GL_CHECK_ERROR( glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;maxTextureSize) );<br />    GL_CHECK_ERROR( glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS, &amp;maxLayerSize) );<br /><br />    <span class="SHComment">//ssLOG_LINE(&quot;maxTextureSize: &quot;&lt;&lt;maxTextureSize);</span><br />    <span class="SHComment">//ssLOG_LINE(&quot;maxLayerSize: &quot;&lt;&lt;maxLayerSize);</span><br /><br />    <span class="SHComment">//maxTextureSize = 1920;</span><br />    maxTextureSize = maxTextureSize &gt; <span class="SHNumber">4096</span> ? <span class="SHNumber">4096</span> : maxTextureSize;<br /><br />    GLint success = GL_FALSE;<br />    <span class="SHKeyword">char</span> infoLog[<span class="SHNumber">512</span>] { <span class="SHNumber">0</span> };<br /><br />    <span class="SHComment">// vertex Shader</span><br />    GLuint vertexShaderId = <span class="SHNumber">0</span>;<br />    GL_CHECK_ERROR( vertexShaderId = glCreateShader(GL_VERTEX_SHADER) );<br />    <span class="SHKeyword">const char</span>* vertShaderP = VertShader.c_str();<br />    GL_CHECK_ERROR( glShaderSource(vertexShaderId, <span class="SHNumber">1</span>, &amp;vertShaderP, NULL) );<br />    GL_CHECK_ERROR( glCompileShader(vertexShaderId) );<br /><br />    {<br />        GL_CHECK_ERROR( glGetShaderiv(vertexShaderId, GL_COMPILE_STATUS, &amp;success) );<br />        <span class="SHKeyword">if</span>(success != GL_TRUE)<br />        {<br />            GL_CHECK_ERROR( glGetShaderInfoLog(vertexShaderId, <span class="SHNumber">512</span>, NULL, infoLog) );<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, <span class="SHString">&quot;Failed to compile shaders:&quot;</span>);<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, infoLog);<br />            ssLOG_EXIT_PROGRAM(<span class="SHNumber">1</span>);<br />        };<br />    }<br /><br />    <span class="SHComment">// fragment Shader</span><br />    GLuint fragmentShaderId = <span class="SHNumber">0</span>;<br />    GL_CHECK_ERROR( fragmentShaderId = glCreateShader(GL_FRAGMENT_SHADER) );<br />    <span class="SHKeyword">const char</span>* fargShaderP = FragShader.c_str();<br />    GL_CHECK_ERROR( glShaderSource(fragmentShaderId, <span class="SHNumber">1</span>, &amp;fargShaderP, NULL) );<br />    GL_CHECK_ERROR( glCompileShader(fragmentShaderId) );<br /><br />    {<br />        GL_CHECK_ERROR( glGetShaderiv(fragmentShaderId, GL_COMPILE_STATUS, &amp;success) );<br />        <span class="SHKeyword">if</span>(success != GL_TRUE)<br />        {<br />            GL_CHECK_ERROR( glGetShaderInfoLog(fragmentShaderId, <span class="SHNumber">512</span>, NULL, infoLog) );<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, <span class="SHString">&quot;Failed to compile shaders:&quot;</span>);<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, infoLog);<br />            ssLOG_EXIT_PROGRAM(<span class="SHNumber">1</span>);<br />        };<br />    }<br /><br />    <span class="SHComment">// shader Program</span><br />    GL_CHECK_ERROR( ProgramId = glCreateProgram() );<br /><br />    GL_CHECK_ERROR( glAttachShader(ProgramId, vertexShaderId) );<br />    GL_CHECK_ERROR( glAttachShader(ProgramId, fragmentShaderId) );<br />    GL_CHECK_ERROR( glLinkProgram(ProgramId) );<br /><br />    <span class="SHComment">// print linking errors if any</span><br />    glGetProgramiv(ProgramId, GL_LINK_STATUS, &amp;success);<br />    {<br />        GL_CHECK_ERROR( glGetProgramiv(ProgramId, GL_LINK_STATUS, &amp;success) );<br />        <span class="SHKeyword">if</span>(success != GL_TRUE)<br />        {<br />            GL_CHECK_ERROR( glGetProgramInfoLog(ProgramId, <span class="SHNumber">512</span>, NULL, infoLog) );<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, <span class="SHString">&quot;Failed to compile shaders:&quot;</span>);<br />            ssGUI_ERROR(ssGUI_BACKEND_TAG, infoLog);<br />            ssLOG_EXIT_PROGRAM(<span class="SHNumber">1</span>);<br />        };<br />    }<br /><br />    GL_CHECK_ERROR( glDetachShader(ProgramId, vertexShaderId) );<br />    GL_CHECK_ERROR( glDetachShader(ProgramId, fragmentShaderId) );<br /><br />    <span class="SHComment">// delete the shaders as they're linked into our program now and no longer necessary</span><br />    GL_CHECK_ERROR( glDeleteShader(vertexShaderId) );<br />    GL_CHECK_ERROR( glDeleteShader(fragmentShaderId) );<br /><br />    GL_CHECK_ERROR( glEnable(GL_TEXTURE_3D) );<br /><br />    GL_CHECK_ERROR( glGenTextures(<span class="SHNumber">1</span>, &amp;CachedImages) );<br />    GL_CHECK_ERROR( glBindTexture(GL_TEXTURE_2D_ARRAY, CachedImages) );<br /><br />    <span class="SHComment">//GL_CHECK_ERROR( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR) );</span><br />    GL_CHECK_ERROR( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST) );<br />    GL_CHECK_ERROR( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST) );<br />    GL_CHECK_ERROR( glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE) );<br />    GL_CHECK_ERROR( glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE) );<br /><br />    GL_CHECK_ERROR( glTexImage3D(   GL_TEXTURE_2D_ARRAY,<br />                                    <span class="SHNumber">0</span>,<br />                                    GL_RGBA8,<br />                                    maxTextureSize,<br />                                    maxTextureSize,<br />                                    <span class="SHNumber">1</span>,<br />                                    <span class="SHNumber">0</span>,<br />                                    GL_RGBA,<br />                                    GL_UNSIGNED_BYTE,<br />                                    NULL) );<br /><br />    GL_CHECK_ERROR( glBindTexture(GL_TEXTURE_2D_ARRAY, <span class="SHNumber">0</span>) );<br /><br />    <span class="SHComment">//Generate ID for VBOs for vertex pos, colors, UVs and UseUVs flag</span><br />    GL_CHECK_ERROR( glGenBuffers(<span class="SHNumber">1</span>, &amp;VertsVBO) );<br />    GL_CHECK_ERROR( glGenBuffers(<span class="SHNumber">1</span>, &amp;ColorsVBO) );<br />    GL_CHECK_ERROR( glGenBuffers(<span class="SHNumber">1</span>, &amp;TexCoordsVBO) );<br />    GL_CHECK_ERROR( glGenBuffers(<span class="SHNumber">1</span>, &amp;TopLeftTexCoordsVBO) );<br />    GL_CHECK_ERROR( glGenBuffers(<span class="SHNumber">1</span>, &amp;BotRightTexCoordsVBO) );<br /><br />    <span class="SHComment">//Generate ID for VAO and bind VBOs and EBO created above to this VAO</span><br />    GL_CHECK_ERROR( glGenVertexArrays(<span class="SHNumber">1</span>, &amp;VAO) );<br /><br />    GL_CHECK_ERROR( glBindAttribLocation(ProgramId, VERT_POS_INDEX, <span class="SHString">&quot;vertPos&quot;</span>) );<br />    GL_CHECK_ERROR( glBindVertexArray(VAO) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, VertsVBO) );<br />    GL_CHECK_ERROR( glVertexAttribPointer(VERT_POS_INDEX, <span class="SHNumber">2</span>, GL_FLOAT, GL_FALSE, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glEnableVertexAttribArray(VERT_POS_INDEX) );<br /><br />    GL_CHECK_ERROR( glBindAttribLocation(ProgramId, VERT_COLOR_INDEX, <span class="SHString">&quot;vertColor&quot;</span>) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, ColorsVBO) );<br />    GL_CHECK_ERROR( glVertexAttribPointer(VERT_COLOR_INDEX, <span class="SHNumber">4</span>, GL_FLOAT, GL_FALSE, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glEnableVertexAttribArray(VERT_COLOR_INDEX) );<br /><br />    GL_CHECK_ERROR( glBindAttribLocation(ProgramId, VERT_TEX_COORD_INDEX, <span class="SHString">&quot;vertTexCoord&quot;</span>) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, TexCoordsVBO) );<br />    GL_CHECK_ERROR( glVertexAttribPointer(VERT_TEX_COORD_INDEX, <span class="SHNumber">3</span>, GL_FLOAT, GL_FALSE, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glEnableVertexAttribArray(VERT_TEX_COORD_INDEX) );<br /><br />    GL_CHECK_ERROR( glBindAttribLocation(ProgramId, VERT_TEX_TOP_LEFT_INDEX, <span class="SHString">&quot;vertTexTopLeft&quot;</span>) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, TopLeftTexCoordsVBO) );<br />    GL_CHECK_ERROR( glVertexAttribPointer(VERT_TEX_TOP_LEFT_INDEX, <span class="SHNumber">3</span>, GL_FLOAT, GL_FALSE, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glEnableVertexAttribArray(VERT_TEX_TOP_LEFT_INDEX) );<br /><br />    GL_CHECK_ERROR( glBindAttribLocation(ProgramId, VERT_TEX_BOT_RIGHT_INDEX, <span class="SHString">&quot;vertTexBotRight&quot;</span>) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, BotRightTexCoordsVBO) );<br />    GL_CHECK_ERROR( glVertexAttribPointer(VERT_TEX_BOT_RIGHT_INDEX, <span class="SHNumber">3</span>, GL_FLOAT, GL_FALSE, <span class="SHNumber">0</span>, <span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glEnableVertexAttribArray(VERT_TEX_BOT_RIGHT_INDEX) );<br /><br />    GL_CHECK_ERROR( glBindVertexArray(<span class="SHNumber">0</span>) );<br />    GL_CHECK_ERROR( glBindBuffer(GL_ARRAY_BUFFER, <span class="SHNumber">0</span>) );<br /><br />    CurrentImageAtlas = <span class="SHKeyword">new</span> ssGUI::Backend::DynamicImageAtlas(  glm::ivec2(maxTextureSize, maxTextureSize),<br />                                                                glm::ivec2(<span class="SHNumber">64</span>, <span class="SHNumber">64</span>),<br />                                                                std::bind(&amp;OpenGL3_3_Common::OnNewAtlasRequest, <span class="SHKeyword">this</span>));<br />}<br /><br /><span class="SHKeyword">const</span> std::<span class="SHKeyword">string</span> OpenGL3_3_Common::VertShader =<br />R<span class="SHString">&quot;(</span><br /><span class="SHString">    #version 330 core</span><br /><br /><span class="SHString">    in vec2 vertPos;</span><br /><span class="SHString">    in vec4 vertColor;</span><br /><span class="SHString">    in vec3 vertTexCoord;</span><br /><span class="SHString">    in vec3 vertTexTopLeft;</span><br /><span class="SHString">    in vec3 vertTexBotRight;</span><br /><br /><span class="SHString">    out vec4 fragColor;</span><br /><span class="SHString">    out vec3 fragTexCoord;</span><br /><span class="SHString">    flat out vec3 fragTexTopLeft;</span><br /><span class="SHString">    flat out vec3 fragTexBotRight;</span><br /><br /><span class="SHString">    uniform mat4 projMatrix;</span><br /><br /><span class="SHString">    void main()</span><br /><span class="SHString">    {</span><br /><span class="SHString">        gl_Position = projMatrix * vec4(vertPos, 0.0, 1.0f);</span><br /><br /><span class="SHString">        fragColor = vertColor;</span><br /><span class="SHString">        fragTexCoord = vertTexCoord;</span><br /><span class="SHString">        fragTexTopLeft = vertTexTopLeft;</span><br /><span class="SHString">        fragTexBotRight = vertTexBotRight;</span><br /><span class="SHString">    }</span><br /><span class="SHString">)&quot;</span>;<br /><br /><span class="SHKeyword">const</span> std::<span class="SHKeyword">string</span> OpenGL3_3_Common::FragShader =<br />R<span class="SHString">&quot;(</span><br /><span class="SHString">    #version 330 core</span><br /><br /><span class="SHString">    #extension GL_ARB_texture_query_lod : enable</span><br /><br /><span class="SHString">    out vec4 outColor;</span><br /><br /><span class="SHString">    in vec4 fragColor;</span><br /><span class="SHString">    in vec3 fragTexCoord;</span><br /><span class="SHString">    flat in vec3 fragTexTopLeft;</span><br /><span class="SHString">    flat in vec3 fragTexBotRight;</span><br /><br /><span class="SHString">    uniform sampler2DArray ourTexture;</span><br /><br /><span class="SHString">    //From: https://stackoverflow.com/questions/24388346/how-to-access-automatic-mipmap-level-in-glsl-fragment-shader-texture</span><br /><span class="SHString">    // Does not take into account GL_TEXTURE_MIN_LOD/GL_TEXTURE_MAX_LOD/GL_TEXTURE_LOD_BIAS,</span><br /><span class="SHString">    // nor implementation-specific flexibility allowed by OpenGL spec</span><br /><span class="SHString">    float mip_map_level(in vec2 texture_coordinate) // in texel units</span><br /><span class="SHString">    {</span><br /><span class="SHString">        vec2  dx_vtc        = dFdx(texture_coordinate);</span><br /><span class="SHString">        vec2  dy_vtc        = dFdy(texture_coordinate);</span><br /><span class="SHString">        float delta_max_sqr = max(dot(dx_vtc, dx_vtc), dot(dy_vtc, dy_vtc));</span><br /><span class="SHString">        float mml = 0.5 * log2(delta_max_sqr);</span><br /><span class="SHString">        return max( 0, mml ); // Thanks @Nims</span><br /><span class="SHString">    }</span><br /><br /><span class="SHString">    vec2 BoundTexCoord(vec2 texCoord, ivec2 texPos, ivec2 texSize)</span><br /><span class="SHString">    {</span><br /><span class="SHString">        return clamp(texCoord, texPos, texPos + texSize - 1);</span><br /><span class="SHString">    }</span><br /><br /><span class="SHString">    void main()</span><br /><span class="SHString">    {</span><br /><span class="SHString">        //Normalize the color</span><br /><span class="SHString">        vec4 fragColorN = fragColor / 255.f;</span><br /><br /><span class="SHString">        //If drawing shape, just output the color</span><br /><span class="SHString">        if(fragTexTopLeft.x &lt; 0)</span><br /><span class="SHString">        {</span><br /><span class="SHString">            outColor = fragColorN;</span><br /><span class="SHString">            return;</span><br /><span class="SHString">        }</span><br /><br /><span class="SHString">        vec3 boundedTexCoord = fragTexCoord;</span><br /><span class="SHString">        vec2 imageSize = (fragTexBotRight - fragTexTopLeft).xy;</span><br /><span class="SHString">        boundedTexCoord.xy = BoundTexCoord(fragTexCoord.xy, ivec2(fragTexTopLeft.xy), ivec2(imageSize));</span><br /><span class="SHString">        float mipmapLevel = 0;</span><br /><br /><span class="SHString">        #ifdef GL_ARB_texture_query_lod</span><br /><span class="SHString">            mipmapLevel = textureQueryLOD(ourTexture, fragTexCoord.xy / textureSize(ourTexture, 0).xy).y;</span><br /><span class="SHString">        #else</span><br /><span class="SHString">            mipmapLevel = mip_map_level(boundedTexCoord.xy);</span><br /><span class="SHString">        #endif</span><br /><br /><span class="SHString">        int lowerDim = min(textureSize(ourTexture, 0).x, textureSize(ourTexture, 0).y);</span><br /><span class="SHString">        const int MAX_LOOP = 99;</span><br /><span class="SHString">        int counter = 1;</span><br /><span class="SHString">        for(int i = 0; i &lt; MAX_LOOP; i++)</span><br /><span class="SHString">        {</span><br /><span class="SHString">            lowerDim = lowerDim &gt;&gt; 1;</span><br /><span class="SHString">            counter++;</span><br /><br /><span class="SHString">            if(lowerDim == 0)</span><br /><span class="SHString">                break;</span><br /><span class="SHString">        }</span><br /><br /><span class="SHString">        int roundedMipmapLevel = int(clamp(mipmapLevel, 0, counter));</span><br /><span class="SHString">        //roundedMipmapLevel = 3;</span><br /><br /><span class="SHString">        //If mipmap level is 0 (base), don't need to do anything</span><br /><span class="SHString">        if(roundedMipmapLevel == 0)</span><br /><span class="SHString">        {</span><br /><span class="SHString">            outColor = texelFetch(ourTexture, ivec3(boundedTexCoord), 0) * (fragColorN);</span><br /><span class="SHString">            return;</span><br /><span class="SHString">        }</span><br /><br /><span class="SHString">        //Otherwise get the localized TexCoord</span><br /><span class="SHString">        vec2 localTexCoord = (boundedTexCoord.xy - fragTexTopLeft.xy);</span><br /><span class="SHString">        vec2 localTexCoordNormalized = localTexCoord / imageSize;</span><br /><br /><span class="SHString">        //NOTE: This in theory is pretty good, but doesn't work because mipmap size is rounded down at each level</span><br /><span class="SHString">        //          and each one is relying on the previous one.</span><br /><span class="SHString">        //Get the mipmap multiplier by doing 0.5 ^ mipmap level</span><br /><span class="SHString">        //float mipmapMultiplier = pow(0.5f, float(roundedMipmapLevel));</span><br /><br /><span class="SHString">        //NOTE: Again, this works on paper but because mipmap is rounded down each time, the offset will be wrong.</span><br /><span class="SHString">        //The coordinate of the mipmap in y can be found by using the nth partial sum of a geometric sequence</span><br /><span class="SHString">        //  with this (modified) formula: (1 - 0.5 ^ mipmapLevel) / (1 - 0.5) - 1</span><br /><span class="SHString">        //float mipmapYOffsetMultiplier = (1.f - mipmapMultiplier) / 0.5f - 1.f;</span><br /><br /><span class="SHString">        //Get the mipmap size and Y offset</span><br /><span class="SHString">        ivec2 mipmapSize = ivec2(imageSize);</span><br /><span class="SHString">        int mipmapYOffset = -mipmapSize.y;</span><br /><br /><span class="SHString">        for(int i = 0; i &lt; MAX_LOOP; i++)</span><br /><span class="SHString">        {</span><br /><span class="SHString">            if(i == roundedMipmapLevel)</span><br /><span class="SHString">                break;</span><br /><br /><span class="SHString">            mipmapYOffset += mipmapSize.y;</span><br /><span class="SHString">            mipmapSize /= 2;</span><br /><span class="SHString">        }</span><br /><br /><span class="SHString">        ivec3 mipmapTopLeft = ivec3(fragTexBotRight.x, fragTexTopLeft.y + mipmapYOffset, fragTexCoord.z);</span><br /><span class="SHString">        vec3 mipmapTexCoord = vec3(localTexCoordNormalized * vec2(mipmapSize), fragTexCoord.z);</span><br /><br /><span class="SHString">        mipmapTexCoord += vec3(mipmapTopLeft.xy, 0);</span><br /><span class="SHString">        mipmapTexCoord.xy = BoundTexCoord(mipmapTexCoord.xy, mipmapTopLeft.xy, mipmapSize);</span><br /><br /><span class="SHString">        //Nearest</span><br /><span class="SHString">        //outColor = texelFetch(ourTexture, ivec3(mipmapTexCoord.xy, fragTexCoord.z), 0) * (fragColorN);</span><br /><span class="SHString">        //return;</span><br /><br /><span class="SHString">        vec2 lowerTexCoord = BoundTexCoord(floor(mipmapTexCoord.xy - vec2(0.5f, 0.5f)) + 0.5f, mipmapTopLeft.xy, mipmapSize);</span><br /><span class="SHString">        vec2 higherTexCoord = BoundTexCoord(floor(mipmapTexCoord.xy + vec2(0.5f, 0.5f)) + 0.5f, mipmapTopLeft.xy, mipmapSize);</span><br /><br /><span class="SHString">        mipmapTexCoord.xy = clamp(mipmapTexCoord.xy, lowerTexCoord, higherTexCoord);</span><br /><br /><span class="SHString">        float totalMultiplier = (higherTexCoord.x - lowerTexCoord.x) * (higherTexCoord.y - lowerTexCoord.y);</span><br /><br /><span class="SHString">        float leftness = (higherTexCoord.x - mipmapTexCoord.x);</span><br /><span class="SHString">        float rightness = (mipmapTexCoord.x - lowerTexCoord.x);</span><br /><span class="SHString">        float topness = (higherTexCoord.y - mipmapTexCoord.y);</span><br /><span class="SHString">        float botness = (mipmapTexCoord.y - lowerTexCoord.y);</span><br /><br /><br /><span class="SHString">        float topLeftMultiplier = leftness * topness / totalMultiplier;</span><br /><span class="SHString">        float topRightMultiplier = rightness * topness / totalMultiplier;</span><br /><span class="SHString">        float botRightMultiplier = rightness * botness / totalMultiplier;</span><br /><span class="SHString">        float botLeftMultiplier = leftness * botness / totalMultiplier;</span><br /><br /><span class="SHString">        vec4 linearColor =  texelFetch(ourTexture, ivec3(lowerTexCoord, fragTexCoord.z), 0) * topLeftMultiplier +</span><br /><span class="SHString">                            texelFetch(ourTexture, ivec3(vec2(higherTexCoord.x, lowerTexCoord.y), fragTexCoord.z), 0) * topRightMultiplier +</span><br /><span class="SHString">                            texelFetch(ourTexture, ivec3(higherTexCoord, fragTexCoord.z), 0) * botRightMultiplier +</span><br /><span class="SHString">                            texelFetch(ourTexture, ivec3(vec2(lowerTexCoord.x, higherTexCoord.y), fragTexCoord.z), 0) * botLeftMultiplier;</span><br /><br /><span class="SHString">        outColor = linearColor * (fragColorN);</span><br /><span class="SHString">    }</span><br /><span class="SHString">)&quot;</span>;</pre></div>
</div>

<a name="Functions"></a><a name="Topic882"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="UpdateViewPortAndModelView"></a><a name="Topic1320"></a><div class="CTopic TFunction LC">
 <div class="CTitle">UpdateViewPortAndModelView</div>
 <div id="NDPrototype1320" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">glm::mat4x4 UpdateViewPortAndModelView(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first">glm::</td><td class="PType">ivec2&nbsp;</td><td class="PName last">widthHeight</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Updates glViewport and return the 4 x 4 matrix that can be used to correctly map the window coordinates in shader</p></div>
</div>

<a name="SaveState"></a><a name="Topic1985"></a><div class="CTopic TFunction LC">
 <div class="CTitle">SaveState</div>
 <div id="NDPrototype1985" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">void</span> SaveState()</div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:SaveState" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1220);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::SaveState</a></p></div>
</div>

<a name="RestoreState"></a><a name="Topic1996"></a><div class="CTopic TFunction LC">
 <div class="CTitle">RestoreState</div>
 <div id="NDPrototype1996" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">void</span> RestoreState()</div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:RestoreState" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1221);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::RestoreState</a></p></div>
</div>

<a name="DrawEntities"></a><a name="Topic1997"></a><div class="CTopic TFunction LC">
 <div class="CTitle">DrawEntities</div>
 <div id="NDPrototype1997" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> DrawEntities(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">const</span> std::</td><td class="PType">vector&lt;<a href="../../../../index.html#CClass:ssGUI.DrawingEntity" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,590);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::DrawingEntity</a>&gt;&amp;&nbsp;</td><td class="PName last">entities</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:DrawEntities" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,802);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::DrawEntities</a></p></div>
</div>

<a name="AddFontCache"></a><a name="Topic2001"></a><div class="CTopic TFunction LC">
 <div class="CTitle">AddFontCache</div>
 <div id="NDPrototype2001" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> AddFontCache(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">CharTextureIdentifier&nbsp;</td><td class="PName last">charTexture</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Adds a texture cache for displaying a character from a font with corresponding font size</p></div>
</div>

<a name="AddImageCache"></a><a name="Topic2057"></a><div class="CTopic TFunction LC">
 <div class="CTitle">AddImageCache</div>
 <div id="NDPrototype2057" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">bool</span> AddImageCache(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><a href="../../../../index.html#CClass:ssGUI.Backend.BackendImageInterface" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1367);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::Backend::</a></td><td class="PType"><a href="../../../../index.html#CClass:ssGUI.Backend.BackendImageInterface" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1367);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendImageInterface</a>*&nbsp;</td><td class="PName last">backendImage</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:AddImageCache" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1225);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::AddImageCache</a></p></div>
</div>

<a name="RemoveFontCache"></a><a name="Topic2122"></a><div class="CTopic TFunction LC">
 <div class="CTitle">RemoveFontCache</div>
 <div id="NDPrototype2122" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> RemoveFontCache(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">CharTextureIdentifier&nbsp;</td><td class="PName last">charTexture</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>This removes the backend font from the cache.</p></div>
</div>

<a name="RemoveImageCache"></a><a name="Topic2164"></a><div class="CTopic TFunction LC">
 <div class="CTitle">RemoveImageCache</div>
 <div id="NDPrototype2164" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> RemoveImageCache(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><a href="../../../../index.html#CClass:ssGUI.Backend.BackendImageInterface" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1367);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >ssGUI::Backend::</a></td><td class="PType"><a href="../../../../index.html#CClass:ssGUI.Backend.BackendImageInterface" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1367);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendImageInterface</a>*&nbsp;</td><td class="PName last">backendImage</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:RemoveImageCache" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1226);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::RemoveImageCache</a></p></div>
</div>

<a name="DrawToBackBuffer"></a><a name="Topic2168"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">DrawToBackBuffer</div>
 <div id="NDPrototype2168" class="NDPrototype"><div class="PSection PPlainSection"><span class="SHKeyword">void</span> DrawToBackBuffer()</div></div>
 <div class="CBody"><p>See <a href="../../../../index.html#CClass:ssGUI.Backend.BackendDrawingInterface:DrawToBackBuffer" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,803);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >BackendDrawingInterface::DrawToBackBuffer</a></p></div>
</div>

</body></html>