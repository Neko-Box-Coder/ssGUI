Title: GUI Object Types

Unlike <EventCallback> and <Extension>, you can create a GUI object either on the stack or the heap.

As mentioned before, all GUI Objects are derived from either <Window> or <Widget> class (which is derived from <BaseGUIObject> which derives from abstract class <GUIObject>).

_

Deriving from those either two classes, we can have either a normal GUI Object or a composite GUI Object.

- A normal GUI Object is the classes we have looked at, such as <Window>, <MainWindow>, <Text>, etc... where it *doesn't require* any GUI objects when being constructed.

Meaning they are all *independent* and can be instantiated on its own.

- A composite GUI object on the other hand, requires other GUI objects when being constructed.

Meaning it is *made up of one or multiple GUI objects*, normally as children. An example will be TextButton (WIP) where a <Text> object is a child of a <Button> object.

We will not touch on composite GUI objects for now, but you should be able to achieve the same result by manually parenting GUI objects to a desired GUI object and attach custom logics to it. 

_

You can easily check what class does a GUI object derived by looking at/navigating the inheritance diagram in the API.

(see APIInheritanceDiagram.png)

(see GUIObjectInheritanceDiagram.png)

Title: GUI Object anchor and position

By default, GUI object's origin is at the top left corner. There are two types of position for a GUI Object:

- Global Position where the position is the *distance* between the *GUI object top left corner* and the *Main Window top left corner*.

- Position (aka local position) is the distance between the GUI object's corner and the parent's corner depending on which corner is anchored.

_

You can anchor a GUI object to either of the four corners. Meaning the GUI object is *stuck* to that corner if you are not changing the position. 

You can also position (and resize) a GUI object using extensions but it will not be covered here for now. You can see the diagram for a more cleared explaination of the positioning system.

(see AnchorTopLeft.png)

(see AnchorBottomRight.png)

Title: Button Class

Lets take a look at the <Button> Class. By default, the <Button> class already has a <Border> extension and <ButtonStateChangedEventCallback> event callback attached.

we will discuss about event callback and extension later. If you remember from <Introduction>, there's an example code showing a button.

=========================== C++ =============================
//Create a button and set an event callback to change the text when it is clicked
ssGUI::Button button;
button.SetSize(glm::ivec2(50, 30));
button.SetPosition(glm::ivec2(225, 85));
button.GetEventCallback(ssGUI::EventCallbacks::ButtonStateChangedEventCallback::EVENT_NAME)->AddEventListener
(
    [&](ssGUI::GUIObject* src)
    {
        if(((ssGUI::Button*)src)->GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)
        {
            text.SetText(L"Button pressed and this text has changed.");
        }
    }
);
=============================================================

_

We create the <Button> object just like other GUI objects we have seen before.

> ssGUI::Button button;

And of course, we can set the size and position of it like other GUI objects.

_

Then we can add functionality by listening any button changes by using the <ButtonStateChangedEventCallback> comes with the Button class. 

For now, you don't need to worry about how to use an event listener. This will be covered in <Event Callback Class>.

The only thing we are interested is this

============================= C++ ================================
if(((ssGUI::Button*)src)->GetButtonState() == ssGUI::Enums::ButtonState::CLICKED)
{
    text.SetText(L"Button pressed and this text has changed.");
}
==================================================================

which is triggered whenever there's anything going on with the button.

_

As you can see, we can tell which state the button is currently in by <Button::GetButtonState()>

> ((ssGUI::Button*)src)->GetButtonState()

There are a total number of 6 states a button can be in, for more details about all the states, please visit <ssGUI.Enums.ButtonState> 

In this case, we are setting the text *after* the button is being clicked.

Title: Image Class

Unlike other GUI classes, this class is slightly different from other classes as it requires reading image data from either the disk or the memory.

Therefore, it requires access to one of the backend interfaces to process the image data. But fear not, it is actually very simple.

========================== C++ =============================
//Creating an image widget
ssGUI::Image image;
image.SetSize(glm::ivec2(300, 300));
image.SetFitting(ssGUI::Enums::ImageFitting::FIT_WHOLE_IMAGE);
image.GetBackendImageInterface()->LoadFromPath("path to your image.png");
image.SetParentP(&mainWindow);
============================================================

Skipping the first two lines as we have already seen it. 

We can set the image to fit different, you can check out <ssGUI::Enums::ImageFitting> for more information.

In this case, we are telling the Image widget to *always* show the whole image.

_

Next we can load the image by accessing the <BackendImageInterface> using

> image.GetBackendImageInterface()

which returns a pointer to the interface.

_

Then we can load the image relative to our executable by calling <BackendImageInterface::LoadFromPath>

Last we just need to attach the image widget to the MainWindow object in order to show it.

Please note that the Image class *DOES NOT* hold the image data, the BackendImageInterface holds the data instead.

[TODO : Image data sharing]

Title: Text Class

Similar to the Image class, the text class requires reading the font data from either the disk or the memory.

There's a built-in <Font> class to process the font data.

============================= C++ ============================
//Loading the font
ssGUI::Font font;
if(font.GetBackendFontInterface()->LoadFromPath("NotoSans-Regular.ttf"))
    std::cout<<"font loaded\n";
=============================================================

_

Then we can just set the font for the <Text> class.

============================= C++ ============================
//Create a text widget and set the respective properties
ssGUI::Text text;
text.SetFont(&font);
=============================================================

However, if we are defining the text to be shown for an area and want the text to wrap around automatically, what do we do?

(see TextNoWrapExample.png)

_

We can easily achieve this by setting the wrapping mode (<ssGUI::Enums::TextWrapping>) to be word wrapping. Like this

> text.SetWrappingMode(ssGUI::Enums::TextWrapping::WORD_WRAPPING);

Then you can see the text is automatically wrapped around. 

(see TextWordWrapExample.png)

_

We can also use <ssGUI::Enums::TextWrapping> ::CHARACTER_WRAPPING for character based languages such as Japanese, Korean, etc...

So it will look something like this:

(see TextCharWrapExample.png)